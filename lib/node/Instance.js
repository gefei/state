"use strict";
exports.__esModule = true;
exports.Instance = void 0;
var _1 = require(".");
var Transaction_1 = require("./Transaction");
/**
 * Represents an instance of a state machine model at runtime; there can be many seperate state machine instances using a common model.
 */
var Instance = /** @class */ (function () {
    /**
     * Creates a new state machine instance conforming to a particular state machine model.
     * @param name The name of the state machine instance.
     * @param root The root state of the state machine instance.
     */
    function Instance(name, root) {
        var _this = this;
        this.name = name;
        this.root = root;
        /** The stable active state configuration of the state machine, conveying the last known state for each region. */
        this.activeStateConfiguration = {};
        /**
         * The deferred triggers awaiting evaluation once the current active state configuration changes.
         * @internal
         * @hidden
         */
        this.deferredEventPool = [];
        this.transactional(function (transaction) {
            _this.root.doEnter(transaction, false, _this.root); // enter the root element
            if (_this.deferredEventPool.length !== 0) {
                _this.evaluateDeferred(transaction);
                _this.deferredEventPool = _this.deferredEventPool.filter(function (t) { return t; }); // repack the deferred event pool
            }
        });
    }
    /**
     * Evaluates a trigger event to see if it causes a state transition.
     * @param trigger The trigger event to evaluate.
     * @returns Returns true if the trigger event caused a change in the active state configuration or was deferred.
     */
    Instance.prototype.evaluate = function (trigger) {
        var _this = this;
        _1.log.write(function () { return _this + " evaluate " + trigger; }, _1.log.Evaluate);
        if (this.transaction) {
            this.defer(trigger);
            return false;
        }
        else {
            return this.transactional(function (transaction) {
                var result = _this.root.evaluate(transaction, false, trigger); // evaluate the trigger event
                if (result && _this.deferredEventPool.length !== 0) { // if there are deferred events, process them
                    _this.evaluateDeferred(transaction);
                    _this.deferredEventPool = _this.deferredEventPool.filter(function (t) { return t; }); // repack the deferred event pool
                }
                return result;
            });
        }
    };
    /**
     * Performs an operation that may alter the active state configuration with a transaction.
     * @param TReturn The return type of the transactional operation.
     * @param operation The operation to perform within a transaction.
     * @return Returns the result of the operation.
     */
    Instance.prototype.transactional = function (operation) {
        try {
            this.transaction = new Transaction_1.Transaction(this);
            var result = operation(this.transaction);
            Object.assign(this.activeStateConfiguration, this.transaction.activeStateConfiguration);
            return result;
        }
        finally {
            this.transaction = undefined;
        }
    };
    /**
     * Add a trigger event to the deferred event pool.
     * @param trigger The trigger event to add to the deferred event pool.
     * @internal
     * @hidden
     */
    Instance.prototype.defer = function (trigger) {
        var _this = this;
        _1.log.write(function () { return _this + " deferring " + trigger; }, _1.log.Evaluate);
        this.deferredEventPool.push(trigger);
    };
    /**
     * Evaluates trigger events in the deferred event pool.
     */
    Instance.prototype.evaluateDeferred = function (transaction) {
        var _this = this;
        this.deferredEventPool.forEach(function (trigger, i) {
            if (trigger && _this.root.getDeferrableTriggers(transaction).indexOf(trigger.constructor) === -1) {
                delete _this.deferredEventPool[i];
                _1.log.write(function () { return _this + " evaluate deferred " + trigger; }, _1.log.Evaluate);
                if (_this.root.evaluate(transaction, false, trigger)) {
                    _this.evaluateDeferred(transaction);
                    return;
                }
            }
        });
    };
    /**
     * Returns the last known state of a region from the stable active state configuration.
     * @param region The region to find the last know state of.
     * @returns Returns the last known state of the region or undefined if the region has not been entered.
     */
    Instance.prototype.getState = function (region) {
        return this.activeStateConfiguration[region.qualifiedName];
    };
    /**
     * Returns the name of the state machine instance.
     * @returns Returns the name of the state machine instance.
     */
    Instance.prototype.toString = function () {
        return this.name;
    };
    return Instance;
}());
exports.Instance = Instance;
